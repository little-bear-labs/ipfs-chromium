diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 6d52b553b21b0..713bd50cda4d0 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -39,6 +39,7 @@ import("//rlz/buildflags/buildflags.gni")
 import("//sandbox/features.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
 import("//third_party/blink/public/public_features.gni")
+import("//third_party/ipfs_client/args.gni")
 import("//third_party/protobuf/proto_library.gni")
 import("//third_party/webrtc/webrtc.gni")
 import("//third_party/widevine/cdm/widevine.gni")
@@ -2582,7 +2583,9 @@ static_library("browser") {
     "//ui/web_dialogs",
     "//ui/webui",
   ]
-
+  if (enable_ipfs) {
+    deps += [ "//components/ipfs" ]
+  }
   if (!is_android) {
     deps += [
       "//chrome/browser/manta/proto:manta_proto",
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index dacd15e30d171..3040cd510566b 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -210,6 +210,7 @@
 #include "third_party/blink/public/common/features_generated.h"
 #include "third_party/blink/public/common/forcedark/forcedark_switches.h"
 #include "third_party/blink/public/common/switches.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 #include "ui/accessibility/accessibility_features.h"
 #include "ui/accessibility/accessibility_switches.h"
 #include "ui/base/ui_base_features.h"
@@ -311,6 +312,10 @@
 #include "extensions/common/switches.h"
 #endif  // BUILDFLAG(ENABLE_EXTENSIONS)
 
+#if BUILDFLAG(ENABLE_IPFS)
+#include "components/ipfs/ipfs_features.h"
+#endif
+
 #if BUILDFLAG(ENABLE_PDF)
 #include "pdf/pdf_features.h"
 #endif
@@ -9890,6 +9895,14 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kOmitCorsClientCertDescription, kOsAll,
      FEATURE_VALUE_TYPE(network::features::kOmitCorsClientCert)},
 
+#if BUILDFLAG(ENABLE_IPFS)
+    {"enable-ipfs",
+     flag_descriptions::kEnableIpfsName,
+     flag_descriptions::kEnableIpfsDescription,
+     kOsMac | kOsWin | kOsLinux,//TODO: These are the only variants currently getting built, but that is not likely to remain the case
+     FEATURE_VALUE_TYPE(ipfs::kEnableIpfs)},
+#endif
+
     {"use-idna2008-non-transitional",
      flag_descriptions::kUseIDNA2008NonTransitionalName,
      flag_descriptions::kUseIDNA2008NonTransitionalDescription, kOsAll,
diff --git a/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc b/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
index 4c88614c68c25..d97d11cc06bf7 100644
--- a/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
+++ b/chrome/browser/autocomplete/chrome_autocomplete_scheme_classifier.cc
@@ -18,6 +18,9 @@
 #include "chrome/browser/ui/android/omnibox/jni_headers/ChromeAutocompleteSchemeClassifier_jni.h"
 #endif
 #include "components/custom_handlers/protocol_handler_registry.h"
+#if BUILDFLAG(ENABLE_IPFS)
+#include "components/ipfs/ipfs_features.h"
+#endif
 #include "content/public/common/url_constants.h"
 #include "url/url_util.h"
 
@@ -55,12 +58,20 @@ ChromeAutocompleteSchemeClassifier::GetInputTypeForScheme(
   if (scheme.empty()) {
     return metrics::OmniboxInputType::EMPTY;
   }
-  if (base::IsStringASCII(scheme) &&
-      (ProfileIOData::IsHandledProtocol(scheme) ||
-       base::EqualsCaseInsensitiveASCII(scheme, content::kViewSourceScheme) ||
-       base::EqualsCaseInsensitiveASCII(scheme, url::kJavaScriptScheme) ||
-       base::EqualsCaseInsensitiveASCII(scheme, url::kDataScheme))) {
-    return metrics::OmniboxInputType::URL;
+  if (base::IsStringASCII(scheme)) {
+      if (ProfileIOData::IsHandledProtocol(scheme) ||
+          base::EqualsCaseInsensitiveASCII(scheme, content::kViewSourceScheme) ||
+          base::EqualsCaseInsensitiveASCII(scheme, url::kJavaScriptScheme) ||
+          base::EqualsCaseInsensitiveASCII(scheme, url::kDataScheme)) {
+        return metrics::OmniboxInputType::URL;
+      }
+#if BUILDFLAG(ENABLE_IPFS)
+      if (base::FeatureList::IsEnabled(ipfs::kEnableIpfs) &&
+         (base::EqualsCaseInsensitiveASCII(scheme, "ipfs") || base::EqualsCaseInsensitiveASCII(scheme, "ipns"))
+          ) {
+        return metrics::OmniboxInputType::URL;
+      }
+#endif
   }
 
   // Also check for schemes registered via registerProtocolHandler(), which
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 54053dfc9b86d..57741ed345f08 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -362,6 +362,7 @@
 #include "third_party/blink/public/common/switches.h"
 #include "third_party/blink/public/mojom/browsing_topics/browsing_topics.mojom.h"
 #include "third_party/blink/public/public_buildflags.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 #include "third_party/widevine/cdm/buildflags.h"
 #include "ui/base/clipboard/clipboard_format_type.h"
 #include "ui/base/l10n/l10n_util.h"
@@ -484,6 +485,12 @@
 #include "chrome/browser/fuchsia/chrome_browser_main_parts_fuchsia.h"
 #endif
 
+#if BUILDFLAG(ENABLE_IPFS)
+#include "components/ipfs/interceptor.h"
+#include "components/ipfs/ipfs_features.h"
+#include "components/ipfs/url_loader_factory.h"
+#endif
+
 #if BUILDFLAG(IS_CHROMEOS)
 #include "base/debug/leak_annotations.h"
 #include "chrome/browser/apps/intent_helper/chromeos_disabled_apps_throttle.h"
@@ -6142,12 +6149,23 @@ void ChromeContentBrowserClient::
         const absl::optional<url::Origin>& request_initiator_origin,
         NonNetworkURLLoaderFactoryMap* factories) {
 #if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-    !BUILDFLAG(IS_ANDROID)
+    !BUILDFLAG(IS_ANDROID) || BUILDFLAG(ENABLE_IPFS)
   content::RenderFrameHost* frame_host =
       RenderFrameHost::FromID(render_process_id, render_frame_id);
   WebContents* web_contents = WebContents::FromRenderFrameHost(frame_host);
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-        // !BUILDFLAG(IS_ANDROID)
+        // !BUILDFLAG(IS_ANDROID) || BUILDFLAG(ENABLE_IPFS)
+#if BUILDFLAG(ENABLE_IPFS)
+  if (base::FeatureList::IsEnabled(ipfs::kEnableIpfs)) {
+    network::mojom::URLLoaderFactory* default_factory = g_browser_process->system_network_context_manager()->GetURLLoaderFactory();
+    ipfs::IpfsURLLoaderFactory::Create(
+      factories,
+      web_contents->GetBrowserContext(),
+      default_factory,
+      GetSystemNetworkContext()
+    );
+  }
+#endif
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (web_contents) {
@@ -6289,6 +6307,11 @@ ChromeContentBrowserClient::WillCreateURLLoaderRequestInterceptors(
     scoped_refptr<base::SequencedTaskRunner> navigation_response_task_runner) {
   std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>
       interceptors;
+#if BUILDFLAG(ENABLE_IPFS)
+  if (base::FeatureList::IsEnabled(ipfs::kEnableIpfs)) {
+    interceptors.push_back(std::make_unique<ipfs::Interceptor>(g_browser_process->system_network_context_manager()->GetURLLoaderFactory(), GetSystemNetworkContext()));
+  }
+#endif
 #if BUILDFLAG(ENABLE_OFFLINE_PAGES)
   interceptors.push_back(
       std::make_unique<offline_pages::OfflinePageURLLoaderRequestInterceptor>(
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index 11f8de137c21d..8bb2cac408b62 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -3034,6 +3034,11 @@
     "owners": [ "hanxi", "wychen" ],
     "expiry_milestone": 130
   },
+  {
+    "name": "enable-ipfs",
+    "owners": [ "//components/ipfs/OWNERS" ],
+    "expiry_milestone": 150
+  },
   {
     "name": "enable-isolated-sandboxed-iframes",
     "owners": [ "wjmaclean@chromium.org", "alexmos@chromium.org", "creis@chromium.org" ],
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 12e695f7d8e2e..34cf4ebf03624 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -254,6 +254,11 @@ const char kEnableBenchmarkingDescription[] =
     "after 3 restarts. On the third restart, the flag will appear to be off "
     "but the effect is still active.";
 
+#if BUILDFLAG(ENABLE_IPFS)
+extern const char kEnableIpfsName[] = "Enable IPFS";
+extern const char kEnableIpfsDescription[] = "Enable ipfs:// and ipns:// URLs";
+#endif
+
 const char kPreloadingOnPerformancePageName[] =
     "Preloading Settings on Performance Page";
 const char kPreloadingOnPerformancePageDescription[] =
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 9a15b7ab7cb8c..63051da51e557 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -22,6 +22,7 @@
 #include "pdf/buildflags.h"
 #include "printing/buildflags/buildflags.h"
 #include "third_party/blink/public/common/buildflags.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 
 // This file declares strings used in chrome://flags. These messages are not
 // translated, because instead of end-users they target Chromium developers and
@@ -158,6 +159,11 @@ extern const char kDownloadWarningImprovementsDescription[];
 extern const char kEnableBenchmarkingName[];
 extern const char kEnableBenchmarkingDescription[];
 
+#if BUILDFLAG(ENABLE_IPFS)
+extern const char kEnableIpfsName[];
+extern const char kEnableIpfsDescription[];
+#endif
+
 #if BUILDFLAG(USE_FONTATIONS_BACKEND)
 extern const char kFontationsFontBackendName[];
 extern const char kFontationsFontBackendDescription[];
@@ -4475,6 +4481,7 @@ extern const char kEnableBoundSessionCredentialsName[];
 extern const char kEnableBoundSessionCredentialsDescription[];
 #endif  // BUILDFLAG(ENABLE_BOUND_SESSION_CREDENTIALS)
 
+
 // ============================================================================
 // Don't just add flags to the end, put them in the right section in
 // alphabetical order. See top instructions for more.
diff --git a/chrome/common/chrome_content_client.cc b/chrome/common/chrome_content_client.cc
index 246ec9c5c911f..4b3a9619cc652 100644
--- a/chrome/common/chrome_content_client.cc
+++ b/chrome/common/chrome_content_client.cc
@@ -53,6 +53,7 @@
 #include "net/http/http_util.h"
 #include "pdf/buildflags.h"
 #include "ppapi/buildflags/buildflags.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 #include "third_party/widevine/cdm/buildflags.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/resource/resource_bundle.h"
@@ -296,6 +297,14 @@ void ChromeContentClient::AddAdditionalSchemes(Schemes* schemes) {
 #if BUILDFLAG(IS_ANDROID)
   schemes->local_schemes.push_back(url::kContentScheme);
 #endif
+  for ( const char* ip_s : {"ipfs", "ipns"} ) {
+    schemes->standard_schemes.push_back(ip_s);
+#if BUILDFLAG(ENABLE_IPFS)
+    schemes->cors_enabled_schemes.push_back(ip_s);
+    schemes->secure_schemes.push_back(ip_s);
+    schemes->csp_bypassing_schemes.push_back(ip_s);
+#endif
+  }
 }
 
 std::u16string ChromeContentClient::GetLocalizedString(int message_id) {
diff --git a/components/open_from_clipboard/clipboard_recent_content_generic.cc b/components/open_from_clipboard/clipboard_recent_content_generic.cc
index 4dcafecbc66c6..5f4fde8808e4f 100644
--- a/components/open_from_clipboard/clipboard_recent_content_generic.cc
+++ b/components/open_from_clipboard/clipboard_recent_content_generic.cc
@@ -12,6 +12,7 @@
 #include "ui/base/clipboard/clipboard.h"
 #include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
 #include "url/url_util.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 
 #if BUILDFLAG(IS_ANDROID)
 #include "ui/base/clipboard/clipboard_android.h"
@@ -21,6 +22,9 @@ namespace {
 // Schemes appropriate for suggestion by ClipboardRecentContent.
 const char* kAuthorizedSchemes[] = {
     url::kAboutScheme, url::kDataScheme, url::kHttpScheme, url::kHttpsScheme,
+#if BUILDFLAG(ENABLE_IPFS)
+    "ipfs", "ipns"
+#endif
     // TODO(mpearson): add support for chrome:// URLs.  Right now the scheme
     // for that lives in content and is accessible via
     // GetEmbedderRepresentationOfAboutScheme() or content::kChromeUIScheme
diff --git a/net/dns/dns_config_service_linux.cc b/net/dns/dns_config_service_linux.cc
index 5273da5190277..12b28b86a4c00 100644
--- a/net/dns/dns_config_service_linux.cc
+++ b/net/dns/dns_config_service_linux.cc
@@ -272,11 +272,11 @@ bool IsNsswitchConfigCompatible(
         // Ignore any entries after `kDns` because Chrome will fallback to the
         // system resolver if a result was not found in DNS.
         return true;
-
+      case NsswitchReader::Service::kResolve:
+        break;
       case NsswitchReader::Service::kMdns:
       case NsswitchReader::Service::kMdns4:
       case NsswitchReader::Service::kMdns6:
-      case NsswitchReader::Service::kResolve:
       case NsswitchReader::Service::kNis:
         RecordIncompatibleNsswitchReason(
             IncompatibleNsswitchReason::kIncompatibleService,
diff --git a/url/BUILD.gn b/url/BUILD.gn
index 4835136a19856..98f346f852f89 100644
--- a/url/BUILD.gn
+++ b/url/BUILD.gn
@@ -5,6 +5,7 @@
 import("//build/buildflag_header.gni")
 import("//testing/libfuzzer/fuzzer_test.gni")
 import("//testing/test.gni")
+import("//third_party/ipfs_client/args.gni")
 import("features.gni")
 
 import("//build/config/cronet/config.gni")
@@ -65,6 +66,7 @@ component("url") {
   public_deps = [
     "//base",
     "//build:robolectric_buildflags",
+    "//third_party/ipfs_client:ipfs_buildflags",
   ]
 
   if (is_robolectric) {
@@ -74,6 +76,11 @@ component("url") {
 
   deps = [ "//base/third_party/dynamic_annotations" ]
 
+  if (enable_ipfs) {
+    sources += [ "url_canon_ipfs.cc" ]
+    deps += [ "//third_party/ipfs_client:ipfs_client" ]
+  }
+
   if (is_win) {
     # Don't conflict with Windows' "url.dll".
     output_name = "url_lib"
diff --git a/url/url_canon.h b/url/url_canon.h
index 94b44426fa33a..d481e73a0ee76 100644
--- a/url/url_canon.h
+++ b/url/url_canon.h
@@ -13,6 +13,7 @@
 #include "base/memory/raw_ptr_exclusion.h"
 #include "base/numerics/clamped_math.h"
 #include "url/third_party/mozilla/url_parse.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 
 namespace url {
 
@@ -688,6 +689,25 @@ bool CanonicalizeMailtoURL(const char16_t* spec,
                            CanonOutput* output,
                            Parsed* new_parsed);
 
+#if BUILDFLAG(ENABLE_IPFS)
+COMPONENT_EXPORT(URL)
+bool CanonicalizeIpfsURL(const char* spec,
+                             int spec_len,
+                             const Parsed& parsed,
+                             SchemeType scheme_type,
+                             CharsetConverter* query_converter,
+                             CanonOutput* output,
+                             Parsed* new_parsed);
+COMPONENT_EXPORT(URL)
+bool CanonicalizeIpfsURL(const char16_t* spec,
+                             int spec_len,
+                             const Parsed& parsed,
+                             SchemeType scheme_type,
+                             CharsetConverter* query_converter,
+                             CanonOutput* output,
+                             Parsed* new_parsed);
+#endif
+
 // Part replacer --------------------------------------------------------------
 
 // Internal structure used for storing separate strings for each component.
diff --git a/url/url_canon_ipfs.cc b/url/url_canon_ipfs.cc
new file mode 100644
index 0000000000000..da3a5f032b5e8
--- /dev/null
+++ b/url/url_canon_ipfs.cc
@@ -0,0 +1,72 @@
+#include "url_canon_internal.h"
+
+#include <libp2p/multi/content_identifier_codec.hpp>
+#include <ipfs_client/identity_cid.h>
+
+#include <sstream>
+
+namespace m = libp2p::multi;
+using Cid      = m::ContentIdentifier;
+using CidCodec = m::ContentIdentifierCodec;
+
+bool url::CanonicalizeIpfsURL(const char* spec,
+                             int spec_len,
+                             const Parsed& parsed,
+                             SchemeType scheme_type,
+                             CharsetConverter* charset_converter,
+                             CanonOutput* output,
+                             Parsed* output_parsed) {
+  if ( spec_len < 1 || !spec ) {
+    return false;
+  }
+  if ( parsed.host.len < 1 ) {
+    return false;
+  }
+  std::string cid_str{ spec + parsed.host.begin, static_cast<std::size_t>(parsed.host.len) };
+  auto maybe_cid = CidCodec::fromString(cid_str);
+  if ( !maybe_cid.has_value() ) {
+    auto e = libp2p::multi::Stringify(maybe_cid.error());
+    std::ostringstream err;
+    err << e << ' '
+      << std::string_view{spec,static_cast<std::size_t>(spec_len)};
+    maybe_cid = ipfs::id_cid::forText( err.str() );
+  }
+  auto cid = maybe_cid.value();
+  if ( cid.version == Cid::Version::V0 ) {
+    //TODO dcheck content_type == DAG_PB && content_address.getType() == sha256
+    cid = Cid{
+        Cid::Version::V1,
+        cid.content_type,
+        cid.content_address
+      };
+  }
+  auto as_str = CidCodec::toString(cid);
+  if ( !as_str.has_value() ) {
+    return false;
+  }
+  std::string stdurl{ spec, static_cast<std::size_t>(parsed.host.begin) };
+  stdurl.append( as_str.value() );
+  stdurl.append( spec + parsed.host.end(), spec_len - parsed.host.end() );
+  spec = stdurl.data();
+  spec_len = static_cast<int>(stdurl.size());
+  Parsed parsed_input;
+  ParseStandardURL(spec, spec_len, &parsed_input);
+  return CanonicalizeStandardURL(
+      spec, spec_len,
+      parsed_input,
+      scheme_type,
+      charset_converter,
+      output, output_parsed
+    );
+}
+bool url::CanonicalizeIpfsURL(const char16_t* spec,
+                             int spec_len,
+                             const Parsed& parsed,
+                             SchemeType scheme_type,
+                             CharsetConverter* query_converter,
+                             CanonOutput* output,
+                              Parsed* new_parsed) {
+  RawCanonOutput<2048> as8;
+  ConvertUTF16ToUTF8(spec, spec_len, &as8);
+  return CanonicalizeIpfsURL(as8.data(), as8.length(), parsed, scheme_type, query_converter, output, new_parsed);
+}
diff --git a/url/url_util.cc b/url/url_util.cc
index 81b546212d93d..43638079a7818 100644
--- a/url/url_util.cc
+++ b/url/url_util.cc
@@ -13,12 +13,15 @@
 #include "base/check_op.h"
 #include "base/compiler_specific.h"
 #include "base/containers/contains.h"
+#include "base/feature_list.h"
 #include "base/no_destructor.h"
 #include "base/strings/string_util.h"
 #include "url/url_canon_internal.h"
 #include "url/url_constants.h"
+#include "url/url_features.h"
 #include "url/url_file.h"
 #include "url/url_util_internal.h"
+#include "third_party/ipfs_client/ipfs_buildflags.h"
 
 namespace url {
 
@@ -276,7 +279,13 @@ bool DoCanonicalize(const CHAR* spec,
     success = CanonicalizeFileSystemURL(spec, spec_len, parsed_input,
                                         charset_converter, output,
                                         output_parsed);
-
+#if BUILDFLAG(ENABLE_IPFS)
+  } else if (DoCompareSchemeComponent(spec, scheme, "ipfs")) {
+    // Switch multibase away from case-sensitive ones before continuing canonicalization.
+    ParseStandardURL(spec, spec_len, &parsed_input);
+    success = CanonicalizeIpfsURL(spec, spec_len, parsed_input, scheme_type,
+                                      charset_converter, output, output_parsed);
+#endif
   } else if (DoIsStandard(spec, scheme, &scheme_type)) {
     // All "normal" URLs.
     ParseStandardURL(spec, spec_len, &parsed_input);
